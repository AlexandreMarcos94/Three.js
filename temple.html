<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - geometry - cube</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body>
	<script type="module">
		// 			IMPORT		//
		import * as THREE from '../../build/three.module.js';
		import {
			OrbitControls
		} from '../jsm/controls/OrbitControls.js';
		//								//

		//		TEXTURES		//
		// ardoise
		const texture = new THREE.TextureLoader().load('../textures/ardoise.jpg');
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		texture.repeat.set(1, 1);
		// ardoise 2
		const texture2 = new THREE.TextureLoader().load('../textures/ardoise2.jpg');
		texture2.wrapS = THREE.RepeatWrapping;
		texture2.wrapT = THREE.RepeatWrapping;
		texture2.repeat.set(1, 1);
		// rock
		const texture3 = new THREE.TextureLoader().load('../textures/rock.jpg');
		texture3.wrapS = THREE.RepeatWrapping;
		texture3.wrapT = THREE.RepeatWrapping;
		texture3.repeat.set(1, 1);
		// Graviers
		const texture4 = new THREE.TextureLoader().load('../textures/graviers.jpg');
		texture4.wrapS = THREE.RepeatWrapping;
		texture4.wrapT = THREE.RepeatWrapping;
		texture4.repeat.set(4, 4);
		//								//

		// 	MATERIALS		 //
		const material = new THREE.MeshPhongMaterial({
			map: texture,
			dithering: true
		});
		const material2 = new THREE.MeshPhongMaterial({
			map: texture2,
			dithering: true
		});
		const material3 = new THREE.MeshPhongMaterial({
			map: texture3,
			dithering: true
		});
		const material4 = new THREE.MeshPhongMaterial({
			map: texture4,
			dithering: true
		});
		//								//

		//		VARIABLES		//
		let camera, scene, renderer;
		const cylinde = [];
		let mesh;
		let controls;
		init();
		animate();
		//								//

		//		FONCTION CREATION BOX		//
		/*	function box() {


			for (let i = 0; i > 4; i++) {
				ceiling[i] = new THREE.Mesh(geometry_ceiling, material);
				console.log(ceiling[i]);
				if (ceiling > 0) {
					ceiling[i].position.x += 200;
					ceiling[i].position.z += 200;
				}
				scene.add(ceiling[i]);
			}
} */

		//Ajout toit						//
		function roof() {
			let roof = [];
			const geometry_toit = new THREE.BoxBufferGeometry(30, 700, 2250);

			for (let i = 1; i < 3; i++) {
				roof[i] = new THREE.Mesh(geometry_toit, material);
				roof[i].receiveShadow = true;
				scene.add(roof[i]);
				if (i == 1) {
					roof[i].position.y = 600; //toit
					roof[i].position.z = -600;
					roof[i].position.x = -330;
					roof[i].rotation.z = 90;
				} else {
					roof[i].position.y = 600; //toit 2
					roof[i].position.z = -600;
					roof[i].position.x = 280;
					roof[i].rotation.z = -90;
				}
			}

			// 	CREATION DU PLAFOND		//
			let ceiling = [];
			for (let i = 0; i < 2; i++) {
				let geometry_ceiling = new THREE.BoxBufferGeometry(1300 - i * 100, 50, 2500 - i * 50);
				ceiling[i] = new THREE.Mesh(geometry_ceiling, material2);
				scene.add(ceiling[i]);
				ceiling[i].position.y = 450 - i * 50;
				ceiling[i].position.x = -25 - i * 50;
				ceiling[i].position.z = -600;
			}
		}
		//											//

		//			GROUND			//
		let geometry_ground = new THREE.BoxBufferGeometry(10000, 50, 10000);
		let ground;
		ground = new THREE.Mesh(geometry_ground, material4);
		scene.add(ground);
		ground.position.y = -250;
		//									//

			//		CRÉATION ESCALIER		//
			function stairs() {
				let stairs = [];
				//const stairs_geo = new THREE.BoxBufferGeometry(1200, 50, 2300);
				for (let i = 0; i < 3; i++) {
					let stairs_geo = new THREE.BoxBufferGeometry(1300 - i * 100, 50, 2500 - i * 50);
					stairs[i] = new THREE.Mesh(stairs_geo, material3);
					scene.add(stairs[i]);
				}

				for (let i = 0; i < 3; i++) {
					stairs[i].position.z = -600;
					stairs[i].position.y = -200 + i * 30;
				}
			}
		//											//

		//	CRÉATION COLONNE	//
		function colonne() {
			const geometry_cylinde = new THREE.CylinderBufferGeometry(70, 70, 600, 64);

			for (let i = 0; i < 14; i++) {
				cylinde[i] = new THREE.Mesh(geometry_cylinde, material2);
				scene.add(cylinde[i]);
			}

			for (let i = 0; i < 7; i++) { // Rangée côté 1
				let positionZ = -1500;
				cylinde[i].position.z = positionZ;
				cylinde[i].position.y = 120;
				cylinde[i].position.x = -400;

				if (i >= 1) {
					cylinde[i].position.z = positionZ + 300 * i;
				}
				// console.log(cylinde[i].position.z += 200);
				// console.log(i);
			}

			for (let i = 7; i < 14; i++) { // Rangée côté 2
				let positionZ = -3600;
				cylinde[i].position.z = positionZ;
				cylinde[i].position.y = 120;
				cylinde[i].position.x = 400;

				if (i >= 1) {
					cylinde[i].position.z = positionZ + 300 * i;
				}
				// console.log(cylinde[i].position.z += 200);
				// console.log(i);
			}
		}
		//												//


		//		FONCTION INIT			//
		function init() {
			//			CAMERA			//
			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 20000);
			camera.position.z = 600;
			camera.position.x = 100;
			camera.position.y = 250;
			//		CREATION SCENE 	//
			scene = new THREE.Scene();
			//	ORBIT CONTROL SETTINGS 	//
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			controls = new OrbitControls(camera, renderer.domElement);
			controls.enableZoom = true;
			controls.target = new THREE.Vector3(10, 25, -600);
			controls.update();
			window.addEventListener('resize', onWindowResize, false);
			//											//

			//	AJOUT DES LIGHTS   //
			const ambient = new THREE.AmbientLight(0xffffff, 0.3);
			scene.add(ambient);
			//										//

			colonne();
			roof();
			stairs();
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			requestAnimationFrame(animate);
			controls.update();
			renderer.render(scene, camera);
		}
	</script>
</body>

</html>
